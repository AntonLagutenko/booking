<script>
// === Параметры скорости/кэша ===
const CACHE_TTL = 60 * 1000; // 1 минута кэша
const DEBOUNCE_MS = 220;

const cache = new Map(); // key => {set: Set(times), ts: timestamp}
let currentFetchController = null;

// debounce helper
function debounce(fn, ms) {
  let t = null;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
}

// === Существующие константы/элементы (как было) ===
const CONFIG = {
  SCRIPT_URL: "https://script.google.com/macros/s/AKfycbycvzGct5s2WPd_XeKW2swweefuXSOex5pA5gjV-0M5lQ1ZadkE5Htq-WPDE2ggxDUJ/exec",
  EMPLOYEES: [
    "Иванов Сергей Петрович", "Петрова Анна Ивановна", "Сидоров Дмитрий Алексеевич",
    "Козлова Мария Викторовна", "Морозов Павел Николаевич", "Васильева Ольга Сергеевна"
  ].sort(),
  WORKING_START: 17,
  WORKING_END: 20,
  SLOT_MINUTES: 10
};

const ALL_SLOTS = (() => {
  const slots = [];
  for (let h = CONFIG.WORKING_START; h < CONFIG.WORKING_END; h++) {
    for (let m = 0; m < 60; m += CONFIG.SLOT_MINUTES) {
      slots.push(`${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}`);
    }
  }
  return slots;
})();

let isUpdating = false;
const datePicker   = document.getElementById("datePicker");
const employeeInput = document.getElementById("employeeInput");
const slotsDiv     = document.getElementById("slotsContainer");
const list = document.getElementById("employeeList");
let currentEmployee = null;

// --- normalizeTime, showSuggestions, selectEmployee и прочие утилиты оставляем — можно вставить ваши реализации ---
function normalizeTime(raw) {
  if (!raw) return null;
  if (raw instanceof Date && !isNaN(raw)) {
    return `${String(raw.getHours()).padStart(2,"0")}:${String(raw.getMinutes()).padStart(2,"0")}`;
  }
  let s = String(raw).trim();
  if (!s) return null;
  if (s.includes("GMT") || s.includes("1899")) {
    const match = s.match(/(\d{1,2}):(\d{2})/);
    if (match) return `${match[1].padStart(2,"0")}:${match[2]}`;
  }
  const parts = s.split(/[:.]/);
  if (parts.length < 2) return null;
  const h = parseInt(parts[0], 10);
  const m = parseInt(parts[1], 10);
  if (isNaN(h) || isNaN(m)) return null;
  return `${h.toString().padStart(2,"0")}:${m.toString().padStart(2,"0")}`;
}

// suggestions (debounced)
function showSuggestionsImmediate() {
  const val = employeeInput.value.trim().toLowerCase();
  list.innerHTML = "";
  list.style.display = "none";
  if (val.length < 1) return;
  const matches = CONFIG.EMPLOYEES.filter(n => n.toLowerCase().includes(val));
  if (!matches.length) return;
  matches.forEach(name => {
    const li = document.createElement("li");
    li.textContent = name;
    li.onclick = () => selectEmployee(name);
    list.appendChild(li);
  });
  list.style.display = "block";
}
const showSuggestions = debounce(showSuggestionsImmediate, 180);

function selectEmployee(name) {
  currentEmployee = name;
  employeeInput.value = name;
  list.style.display = "none";
  updateSlots(); // вызываем обновление (оно тоже дебаунсится)
}

employeeInput.addEventListener("input", showSuggestions);
employeeInput.addEventListener("focus", showSuggestions);
document.addEventListener("click", e => {
  if (!employeeInput.contains(e.target) && !list.contains(e.target)) {
    list.style.display = "none";
  }
});

// --- Работа с датами/слотами, с кэшем и отменой запросов ---
datePicker.min = new Date().toISOString().split("T")[0];
datePicker.value = datePicker.min;

// fetchBooked теперь поддерживает signal
async function fetchBooked(employee, date, force = false, signal = undefined) {
  try {
    const params = new URLSearchParams({ employee: encodeURIComponent(employee), date });
    if (force) params.append("_", Date.now());
    const res = await fetch(`${CONFIG.SCRIPT_URL}?${params}`, { cache: "no-store", signal });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const json = await res.json();
    if (json.status !== "ok") return new Set();
    const times = (json.booked || []).map(normalizeTime).filter(Boolean);
    return new Set(times);
  } catch (err) {
    if (err.name === 'AbortError') {
      // Запрос отменён — не логируем как ошибку
      console.debug("fetchBooked aborted");
      throw err;
    }
    console.error("fetchBooked:", err);
    return new Set();
  }
}

function showLoading() {
  slotsDiv.innerHTML = `
    <div class="loading-dots-container">
      <div class="loading-dot"></div><div class="loading-dot"></div><div class="loading-dot"></div>
    </div>
    <p style="text-align:center; color:#6b7280; margin:1.5rem 0 0;">Загрузка слотов...</p>
  `;
}

function showEmpty() {
  slotsDiv.innerHTML = '<p style="color:#6b7280; text-align:center">Выберите сотрудника и дату</p>';
}

function renderSlots(bookedSet) {
  const frag = document.createDocumentFragment();
  ALL_SLOTS.forEach(time => {
    const el = document.createElement("div");
    el.className = "slot";
    el.textContent = time;
    if (bookedSet.has(time)) {
      el.classList.add("booked");
      el.title = "Занято";
    } else {
      el.title = "Св��бодно — кликните для записи";
      el.onclick = () => book(time, datePicker.value);
    }
    frag.appendChild(el);
  });
  slotsDiv.innerHTML = "";
  slotsDiv.appendChild(frag);
}

// Обёртка updateSlots с дебаунсом, кэшем и AbortController
const updateSlotsImmediate = async () => {
  if (isUpdating) return;
  isUpdating = true;

  if (!currentEmployee || !datePicker.value) {
    showEmpty();
    isUpdating = false;
    return;
  }

  const key = `${currentEmployee}|${datePicker.value}`;
  const cached = cache.get(key);
  const now = Date.now();

  // Если есть свежий кэш — немедленно отрисовать
  if (cached && (now - cached.ts) < CACHE_TTL) {
    renderSlots(cached.set);
    // всё равно обновим в фоне, но не блокируем UI
    (async () => {
      try {
        // отменяем предыдущий фоновый запрос
        if (currentFetchController) currentFetchController.abort();
        currentFetchController = new AbortController();
        const fresh = await fetchBooked(currentEmployee, datePicker.value, false, currentFetchController.signal);
        cache.set(key, { set: fresh, ts: Date.now() });
        // если данные изменились — обновим UI (могли занять слоты)
        renderSlots(fresh);
      } catch (err) {
        if (err.name !== 'AbortError') console.debug("background refresh failed", err);
      } finally {
        currentFetchController = null;
      }
    })();
    isUpdating = false;
    return;
  }

  // нет кэша или устарел — показываем индикатор и фетчим
  showLoading();

  try {
    // отменяем предыдущий запрос (важно при быстром переключении)
    if (currentFetchController) currentFetchController.abort();
    currentFetchController = new AbortController();
    const booked = await fetchBooked(currentEmployee, datePicker.value, false, currentFetchController.signal);
    cache.set(key, { set: booked, ts: Date.now() });
    renderSlots(booked);
  } catch (err) {
    if (err.name !== 'AbortError') {
      showEmpty();
    }
  } finally {
    currentFetchController = null;
    isUpdating = false;
  }
};
const updateSlots = debounce(updateSlotsImmediate, DEBOUNCE_MS);

// --- Сброс интерфейса ---
function resetForNewBooking() {
  datePicker.disabled = false;
  employeeInput.disabled = false;
  employeeInput.placeholder = "Начните вводить фамилию...";
  currentEmployee = null;
  employeeInput.value = "";
  list.style.display = "none";
  datePicker.value = datePicker.min;
  showEmpty();
}

// --- Создание записи: оптимистическое обновление кэша при успехе ---
async function book(time, date) {
  if (!confirm(`Записаться на ${date} ${time} к ${currentEmployee}?`)) return;

  const client = prompt("Ваше ФИО")?.trim() || "—";
  const phone  = prompt("Телефон")?.trim();

  if (!phone) {
    alert("Укажите номер телефона");
    return;
  }

  // Блокируем поля ввода
  datePicker.disabled = true;
  employeeInput.disabled = true;
  employeeInput.placeholder = "Запись в процессе...";

  // Показываем индикатор процесса
  slotsDiv.innerHTML = `
    <div class="process-state">
      <div class="loading-dots-container" style="padding:3rem 0;">
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
      </div>
      <p style="font-size:1.25rem; margin-top:1rem; color:#166534;">
        Создаём запись...
      </p>
    </div>
  `;

  const payload = { date, time, employee: currentEmployee, client, phone };

  try {
    const res = await fetch(CONFIG.SCRIPT_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const data = await res.json();

    if (data.status === "ok") {
      // обновляем кэш оптимистично: пометим слот занятым
      const key = `${currentEmployee}|${date}`;
      const entry = cache.get(key);
      if (entry) {
        entry.set.add(time);
        entry.ts = Date.now();
      } else {
        const s = new Set([time]);
        cache.set(key, { set: s, ts: Date.now() });
      }

      // Показываем успех
      slotsDiv.innerHTML = `
        <div class="success-state">
          <div class="icon">✔</div>
          <h2>Запись успешно создана!</h2>
          <p style="margin:1rem 0; font-size:1.1rem;">
            ${client}<br>
            ${phone}<br>
            ${date} в ${time}
          </p>
          <small style="color:#6b7280;">Спасибо за запись</small>
          <button id="newBookingBtn" class="btn-new">Новая запись</button>
        </div>
      `;
      const btn = document.getElementById("newBookingBtn");
      if (btn) btn.addEventListener("click", () => { resetForNewBooking(); });

    } else {
      throw new Error(data.message || "Ошибка сервера");
    }
  } catch (err) {
    console.error(err);
    slotsDiv.innerHTML = `
      <div class="error-state">
        <div class="icon">✗</div>
        <h2>Не удалось создать запись</h2>
        <p>${err.message || "Ошибка связи"}</p>
      </div>
    `;
    // разблокируем поля после ошибки
    datePicker.disabled = false;
    employeeInput.disabled = false;
    employeeInput.placeholder = "Начните вводить фамилию...";
  }
}

// --- Инициализация событий ---
datePicker.addEventListener("change", updateSlots);
</script>
